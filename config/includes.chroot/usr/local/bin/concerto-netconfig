#!/usr/bin/env ruby

require 'rubygems'
require 'json'

class WiredConnection
    def initialize(args)
        if args['interface_name']
            @ifname = args['interface_name']
        end
    end

    # Write any necessary auxiliary configuration files
    def write_configs
        # We don't need any.
    end

    # Return the name of the interface to be configured.
    def interface_name
        if @ifname
            # the user has specified an interface to use
            @ifname
        else
            # scan for the first wired interface that has media
            scan_interfaces
        end
    end
    
    # Return any additional lines needed in the interfaces file
    # e.g. referencing WPA config files...
    def interfaces_lines
        # Nothing special needed for wired connections.
        []
    end

private
    def interface_connected(iface)
        results = `/sbin/mii-tool #{iface}`
        if results =~ /link ok/
            true
        else
            false
        end
    end

    def wired_interfaces
        # This is somewhat Linux specific, and may not be all encompassing.
        devices = Dir.glob('/sys/class/net/eth*')
        devices.map { |d| File.basename(d) }
    end

    def scan_interfaces
        wired_interfaces.each do |iface|
            system("ifconfig #{iface} up")
            sleep 10
            if interface_connected(iface)
                return iface
            end
            system("ifconfig #{iface} down")
        end

        # if we get here no interface was found with a cable attached
        # default to eth0 and hope for the best
        STDERR.puts "warning: no suitable interface found, defaulting to eth0"
        'eth0'
    end
end

class WirelessConnection
    def initialize(args)
        @ssid = args['ssid']
        @force_iface = args['iface'] if args['iface']
        @wpa_config_file = '/tmp/wpa_supplicant.concerto.conf'
    end

    def interface_name
        # If the user has requested a specific interface, use it.
        # Otherwise, just pick the first wlan interface, assuming
        # it works and all wlan interfaces have approximately equal
        # reception. When this assumption is wrong the user must force.
        @force_iface || wireless_interfaces[0]
    end

    def write_configs
        # Write a wpa_supplicant.conf file for an unsecured network.
        File.open(@wpa_config_file, 'w') do |wpaconf|
            # long lines, sorry!
            wpaconf.puts "ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=wheel"
            wpaconf.puts "network={"
            wpaconf.puts "ssid=\"#{@ssid}\""
            wpaconf.puts "scan_ssid=1"
            wpaconf.puts "key_mgmt=NONE"
            wpaconf.puts "}"
        end
    end

    def interfaces_lines
        ["wpa-conf #{@wpa_config_file}"]
    end

private

    def wireless_interfaces
        # This is somewhat Linux specific, and may not be all encompassing.
        devices = Dir.glob('/sys/class/net/{ath,wlan}*')
        devices.map { |d| File.basename(d) }
    end
end

class StaticAddressing
    def initialize(args)
        @nameservers = args['nameservers']
        @addr = args['address']
        @mask = args['netmask']
        @gateway = args['gateway']
    end

    def addressing_type
        'static'
    end

    def interfaces_lines
        [
            "address #{@addr}",
            "netmask #{@mask}",
            "gateway #{@gateway}"
        ]
    end

    def write_configs
        File.open('/etc/resolv.conf','w') do |resolvconf|
            @nameservers.each do |nameserver|
                resolvconf.puts("nameserver #{nameserver}");
            end
        end
    end
end

class DHCPAddressing
    def initialize(args)
        # we accept no args
    end

    def addressing_type
        'dhcp'
    end

    def interfaces_lines
        # DHCP needs no additional interfaces args from the addressing side
        []
    end

    def write_configs
        # dhclient will write our resolv.conf so we do not need to do anything
    end
end

input = STDIN.read
args = JSON.parse(input)

connection_method_class = Object.const_get(args['connection_method'])
addressing_method_class = Object.const_get(args['addressing_method'])

connection_method = connection_method_class.new(
    args['connection_method_args']
)

addressing_method = addressing_method_class.new(
    args['addressing_method_args']
)

ifname = connection_method.interface_name

puts "# Concerto Live network configuration"
puts "# Generated by netconfig.rb"
puts "# Changes will be lost on reboot"
puts "auto #{ifname}"
puts "iface #{ifname} inet #{addressing_method.addressing_type}"

addressing_method.interfaces_lines.each do |line|
    puts "\t#{line}"
end

connection_method.interfaces_lines.each do |line|
    puts "\t#{line}"
end

connection_method.write_configs
